# ***** ФУНКЦИИ *****

# Функции - это обычно "фабрики", которые на выход принимают какие-либо данные и на выход возвращают другие данные

# 1 вариант. Функция, которая на вход ничего не принимает и на выход ничего не возвращает.

def func1():
    print("hello world!")

def func2():
    name = "Alexey"
    print(f"hello {name} !")

# 2 вариант. Функция, которая принимает даннаые (имеет вход(-ы) (аргументы)), но ничего не возвращает

def func3 (argument_1, arg_2):
    result = argument_1 + arg_2
    print(result)

# вызов функции с передачей парамаетров аргументам
# func3(100, 55)

# 2.1 вариант. Функция, принимающая данные, но ничего не возвращает, причем аргументы имеют значение по умолчанию. 

def func4 (arg_1, arg_2, arg_3=10):
    result = arg_1 + arg_2 * arg_3
    print(result)

# func4(100,20,5)

# 2.2 вариант. Функция, принимающая данные, но ничего не возвращает
# позиционные параметры

def func5 (arg_1=10, arg_2=20, arg_3=30):
    result = arg_1 + arg_2 + arg_3
    print(result)

# func5(2, 3, 4) 
# func5(100,20)

# 2.3 вариант. Функция, принимающая данные, но ничего не возвращает
# именованные параметры

def func6 (arg_1=10, arg_2=20, arg_3=30):
    result = arg_1 + arg_2 + arg_3
    print(result)

# func6(arg_3=100, arg_1=1)

# 2.4 вариант. Функция, принимающая данные, но ничего не возвращает
# множественные позиционные параметры

def func7(*args):
    print(args)

# можно передавать произвольное количество позиционных данных
# они будут упаковыаны в виде кортежа    

# func7(10,29,30, "lpa", [1,2,3])

def func8(*args):
    """
    функция которая склвадывает произвольное количество параметров
    """     
    result = 1
    for num in args:
        result += num
    print(result)

# func8(100,2, aat)

# 2.5 вариант. Функция, принимающая данные, но ничего не возвращает
# множественные именованные параметры

def func9(**args):
    print(args)

# можно передавать произвольное количество именованных параметров
# они будут упакоываны в виде словаря
#func9(x=100, y=200, z=300)

import math

def distance_calculate(**args):
    """
    функция, которая вычисляет дистанцию от начала координат (0,0,0) до точки с координатами (x,y,z)

    """
    # переменная keys будет хранить список ключей аргументов из args
    keys = list(args.keys())
    
    # для вычисления дистанции применяем теорему Пифагора 
    summa = 0
    # 
    for axis in keys:
        # суммирование квадратов катетов (значений координатных осей)
        summa += args[axis] ** 2
    
    # извлечение квадратного корня
    distance = math.sqrt(summa)

    print(f"Дистанция: {distance}")

# вызов функции
# distance_calculate(x = 10, y = 20, z = 10, a = 5, b = 1)



# вариант 3. Функция, которая принимает параметры и возвращает результаты

def func10(x,y):
    summa = x + y
    return summa

result = func10(10,20)

#print(result)

# передача возвращаемого значения из одной функции в другую "на лету"
# print(func10(1,2))

# ФУНКЦИЯ ВОЗВРАЩАЮЩАЯ 2 ЗНАЧЕНИЯ

def func11(x,y):
    res1 = x ** 2
    res2 = y ** 3
    return res1, res2

# print(func11(2,3))

# ПРИСВОЕНИЕ НЕСКОЛЬКИХ ВОЗВРАЩАЕМЫХ ЗНАЧЕНИЙ В ПЕРЕМЕННЫЕ 
a,b = func11(2,4)

# print(a,b)


# ***** БЕЗЫМЯННЫЕ ФУНКЦИИ (ЛЯМБДА-ФУНКЦИИ, ЛЯМБДА-ВЫРАЖЕНИЯ) (СОКРАЩАЕТ КОД, ИСПОЛЬЗУЕТСЯ ВМЕСТО DEF ЕСЛИ ЭТО ПОЗВОЛЯЕТ) *****

# Создание лямбда-выражения  (lambda параметр: что должно быть)

foo = lambda x,y: (x * y) + (x * y)

# ВЫЗОВ ЛЯМБДА-ВЫРАЖЕНИЯ С ПЕРЕДАЧЕЙ ПАРАМЕТРОВ И ПЕРЕДАЧА ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ "НА ЛЕТУ"
# print(foo(2,3))

# ВЫЗОВ ЛЯМБДА-ВЫРАЖЕНИЯ С ПЕРЕДАЧЕЙ ПАРАМЕТРОВ И ПРИСВОЕНИЕ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ В ПЕРЕМЕННУЮ

res = foo(5,10)
# print(res)

# ПРИМЕР. ЛЯМБДА ВНУТРИ ГЕНЕРАТОРА СПИСКА  (for i - переменная i)

my_list = [(lambda arg: arg ** 2)(i) for i in range(1,10) ]

# print(my_list)

# ПРИМЕР. ЛЯМБДА ВНУТРИ СПИСКА.

lambdaList = [lambda x, y: x + y, lambda x, y: x * y]

# res = lambdaList[0](10,20)
res = lambdaList[1](10,20)

# print(res)

# ПРИМЕР. ЛЯМБДА ВНУТРИ СЛОВАРЯ.

lambdaDict = {"сумма": lambda x,y: x + y, "произведение": lambda x, y: x * y}
res = lambdaDict["сумма"](10,20)
res2 = lambdaDict["произведение"](10,20)

# print(res,res2)

# ***** ДЕКОРАТОРЫ - Т.К. НАЗЫВАЕМЫЙ ПОВЕДЕНЧЕСКИЙ ПАТТЕРН (ШАБЛОН) ПРОГРАММИРОВАНИЯ, *****

# декорируют функции - добавляют дополнительный функционал обернутым функциям 

# СОБСТВЕННО ФУНКЦИЯ-ДЕКОРАТОР

def decorator(func):
    ''' 
    func : аргумент, которому присваивается объект целевой функции
    '''
    # функция-обертка
    def wrapper():
        # должен быть код, который выполняется ДО выполнения целевой функции 
        print("foo")
        
        # вызывается целевая функция из аргумента
        func()
       
        # код, который выполняется ПОСЛЕ выполнения целевой функции
        print("bar")

    return wrapper

# целевая(таргетная) функция

def myFunc1():
    print("Hello")

# присваиваем задекорированную функцию в старое название
myFunc1 = decorator(myFunc1)

# ***** НОВЫЙ СПОСОБ ПРИМЕНЕНИЯ ДЕКОРАТОРА *****

# целевая(таргетная) функция
@decorator
def myFunc2():
    print("Hello")

@decorator
def myFunc3():
    print("Привет!")

# ВЫЗОВ ЗАДЕКОРИРОВАННОЙ ФУНКЦИИ 
# myFunc1()


# ДЕКОРИРОВАНИЕ ФУНКЦИИ, КОТОРАЯ ИМЕЕТ АРГУМЕНТЫ И ВОЗВРАЩАЕТ ЗНАЧЕНИЯ

def decorator1(func):
    def wrapper(a, b):
        print(f"ДО: {a}, {b}")
        print(func(a, b))
        print(f"ПОСЛЕ: {a*2}, {b*2}")
        # return res
    return wrapper

@decorator1
def targetFunc(x,y):
    return x ** y

targetFunc(10, 2)
        
