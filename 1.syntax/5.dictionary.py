#     ***** СЛОВАРИ *****  тип встроенной коллекции

# СОЗДАНИЕ СЛОВАРЯ  (ключи у словарей, это аналог индексов у списков и кортежей)
# {ключ:значение} - пара

my_dict = {1:100, 2:200, "a":"hello", "abc": (10,20,30)}

# ЧТЕНИЕ ДАННЫХ ------------

item = my_dict["a"]

# ИЗМЕНЕНИЕ ДАННЫХ ------------

my_dict["a"] = 3.14

# УДАЛЕНИЕ ДАННЫХ ------------

# del my_dict["a"]

# ДОБАВЛЕНИЕ ДАННЫХ ------------

my_dict["new_key"] = "altanSchool"
my_dict["second_key"] = True

# ПРОБЛЕМА С ЧТЕНИЕМ ДАННЫХ ------------

# ПЕРВЫЙ вариант решения проблемы

# val = my_dict["key2"]

k = "key2" 
# if k in my_dict:
#     val = my_dict[k]
# else:
#     val = "такого ключа не существует"


# ВТОРОЙ вариант решения проблемы  /  метод get аналог вышеуказанному коду

# val = my_dict.get(k)   -  get возвращает дефолтное значение None (при отсутствии в словаре)
val = my_dict.get("abc", "такого ключа не существует")   # - get возвращает пользовательское значение (любое значение (строка, число или ключ в словаре))  (при отсутствии в словаре)


# ПРОБЛЕМА ПРИ УДАЛЕНИИ НЕСУЩЕСТВУЮЩИХ КЛЮЧЕЙ ------------ 

k2 = "key3"

# del my_dict[k2]

# ПЕРВЫЙ ВАРИАНТ КАК ПЕРВЫЙ С ЧТЕНИЕМ ДАННЫХ

# ВТОРОЙ ВАРИАНТ с методом POP

val = my_dict.pop("abc", "такого ключа не существует")  # - pop возвращает пользовательское значение

# КОПИРОВАНИЕ СЛОВАРЯ ------------

d_1 = {"A":100, "B":200, "C":300}

# d_2 = d_1  # -  ДАННАЯ ОПЕРАЦИЯ НЕ КОПИРУЕТ! А ОБРАЩАЕТСЯ К ИСХОДНОМУ СЛОВАРЮ С ВОЗМОЖНОСТЬЮ РЕДАКТИРОВАНИЯ (аналогия - ярлык)

# d_2["A"] = 10

d_2 = d_1.copy()

d_2["A"] = 10

# ОБНОВЛЕНИЕ ДАННЫХ ------------ (не характерен для других коллекций)

# ОБНОВЛЕНИЕ СУЩЕСТВУЮЩЕГО ЗНАЧЕНИЯ

d_3 = {"B":777}
#d_1.update(d_3)

# ОБНОВЛЕНИЕ СУЩЕСТВУЮЩЕГО ЗНАЧЕНИЯ И ДОБАВЛЕНИЕ НОВОГО ЭЛЕМЕНТА

d_4 = {"B":777, "D":1000}
d_1.update(d_4)
print(d_1)


# ДОМАШКА ------------ 
# Изучить другие методы